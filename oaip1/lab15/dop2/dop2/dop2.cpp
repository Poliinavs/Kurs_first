#include "Hash.h"
#include <iostream>

int HashFunction(int key, int size, int p)
// хэш-функция для расчёта позиции вставляемого или искомого Э-а
// int key - значение ключа, int size - максимальное к-во Э-в, int p - к-во коллизий
// функция используется при поиске и при вставке, а при удалении используется функция поиска, а следовательно и хэш-функция
{
	return ((int)(key % size + (key % size + 1) * p) % size);
}

int Next_hash(int key, int size, int p)			// p - счётчик колизий
{
	return ((key % size + (key % size + 1) * p) % size);	// расчёт хэш-функции по заданию
}

Object Create(int size, int(*getkey)(void*)) // функция создания хэш-таблицы 
											 // int(*getkey)(void*) - функция getkey должна принимать указатель на произвольные данные void* и возвращать целое число int
{
	return *(new Object(size, getkey));	// создаём новую хэш-таблиццу и возвращаем её 
										// new - создаёт таблицу и даёт указатель на неё
										// * - получаем поуказателю саму хэш-таблицу
										// size- размер хэш-таблицы
										// getkey - функция для получения ключа из элемента в таблице
}

Object::Object(int size, int(*getkey)(void*))	// конструктор хъш-таблиц
{
	N = 0;	// задаём текущее число элементов, равное нулю
			// this - указатель на текущую структуру (т.е. хэш-таблицу)
	this->Size = size;			// задаём указанный максимальный размер 
	this->GetKey = getkey;		// запоминаем функцию для получения ключа из элемента
	this->Data = new void* [size];	// выделение памяти под массив элементов 
	for (int i = 0; i < size; ++i)	// устанавливаем все элементыв ноль для обозначения их пустоты
		Data[i] = NULL;
}

bool Object::Insert(void* d)	// функция вставки элементов в хэш-таблицу
{
	bool b = false;
	if (N != Size) // если текущее количество не равно размеру хэш-таблиц (ещё есть свободные места)
				   // i - счётчик колизий, t - ключ вставляемого элемента, получаемый функцией GetKey, 
				   // j - позиция для вставки, расчитываем по хэш-функции HashFunction
		for (int i = 0, t = GetKey(d), j = HashFunction(t, Size, 0); i != Size * Size && !b; j = Next_hash(j, Size, ++i))

			// i != Size&&!b - пока счётчик колизий не достигнет размера хэш-таблицы и пока элемент небудет вставлен 														// j = Next_hash(j, Size, ++i) - при колизиях увеличиваем счётчик и пересччитываем позицию по хэш-функции
			if (Data[j] == NULL || Data[j] == DEL)
				// если расчитанная позиция всегдабыла свободна или элемент, который на ней был, был удалён
			{
				Data[j] = d;
				// записываем в рассчитанную позицию вставляемый Э-т, то есть структуру, содержащую ключ	
				N++; 		// увеличиваем счётчик Э-ов
				b = true;	// признак выхода из цикла, то есть Э-т уже вставлен
			}
	return b;
}

int Object::SearchInd(int key) // функция поиска позиции Э-а (структуры) по ключу в хэш-таблице
{
	int t = -1;		// номер найденного Э-а, если ничего не нашли, то возвращает функция -1
	bool b = false;	// признак найден Э-т или нет
	if (N != 0) 		// если в таблице уже есть Э-ты, то есть текущее к-во Э-в!=0 
		for (int i = 0, j = HashFunction(key, Size, 0); Data[j] != NULL && i != Size * Size && !b; j = HashFunction(key, Size, ++i))
			// i - счётчик колизий, j - позиция для поиска искомого Э-а, расчитываем по хэш-функции HashFunction
			// Data[j] != NULL && i != Size&&!b - Data[j] - пока У-ль на Э-т (структуру) на рассчитанной позиции НЕ NULL, то есть пока мы не дойдём до пустого Э-а и пока счётчик коллизий не дойдёт до размера хэш-таблицы И пока элемент не будет вставлен: должны выполнятся ВСЕ 3 УСЛОВИЯ ОДНОВРЕМЕННО для продолжения цикла
			// j = HashFunction(key, Size, ++i) -  позиция для поиска искомого Э-а, расчитываем по хэш-функции HashFunction, то есть если возникла коллизия, то пересчитываем хэш-функцию заново
			if (Data[j] != DEL) // если на текущей позиции не удалён Э-т
				if (GetKey(Data[j]) == key)
					// сравниваем ключ эл-та на тек. позиции с искомым ключом
				{
					// если совпадают ключи, то запоминаем позицию заданного эл-та 
					t = j; // номер найденного эл-та	
					b = true; // -1 , если эл-т не найден
				}
	return t; // возвращ. позицию найденного эл-та
}

void* Object::Search(int key) // функция поиска Э-та по ключу
{
	int t = SearchInd(key);
	// вызываем функцию поиска позиции по ключу и записываем в перемнную t эту позицию
	return (t >= 0) ? (Data[t]) : (NULL);
	// если эл-т найден (t >= 0), возвращаем хранящиеся в нем данные, иначе возвращ. 0
}

void* Object::Delete(int key) // функция удаления по ключу, которая возвращает У-ль на данные, У-ль на которые будет удалён из хэш-таблицы
{
	int i = SearchInd(key);
	// вызываем функцию поиска позиции по ключу и записываем в перемнную t эту позицию
	void* t = Data[i]; // У-ль на данные в стороке хэш-таблицы с найденной позицией
	if (t != NULL) // если данные есть
	{
		Data[i] = DEL; // в качестве нового значения указателя записываем -1, то есть показываем, что Э-т в этой позиции был удален
		N--; // уменьшам кол-во текущих Э-в
	}
	return t;
}

bool Object::Delete(void* d) // функция удаления Э-а по данным
{
	// 1. получаем ключ по переданным данным: (GetKey(d)
	// 2. вызываемфункцию удаления по найденному ключу
	// 3. возвращаем сравнение результата фунции удаления с NULLом
	return (Delete(GetKey(d)) != NULL);
}

void Object::Scan(void(*f)(void*))
// функция вывода хэш-таблицы, которая принимает функцию для вывода одного Э-а
// а та в свою очередь принимает в качестве аргумента У-ль на произвольные данные
{
	for (int i = 0; i < this->Size; i++) // цикл для вывода хэш-таблицы построчно
	{
		std::cout << " Элемент " << i << ": ";
		if ((this->Data)[i] == NULL) // если данных нет и не было
			std::cout << " пусто" << std::endl;
		else if ((this->Data)[i] == DEL)
			// если данных нет, но они были до этого, а потом их удалили
			std::cout << " удален" << std::endl;
		else f((this->Data)[i]); // выводим значение Э-та (структуру) при помощи заданной функции
	}
}


double  Object::koefzap() // функция для расчёта коэффициента заполненности хэш-таблицы
{
	return (double)N / Size;// текущее к-во Э-в делим на максимальное к-во Э-в в хэш-таблице (её размер), возвращаем дробное число
}